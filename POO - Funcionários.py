# -*- coding: utf-8 -*-
"""teste lambda.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UP6fYHMy1rGLy-_4vhRsOsCZXAMdev_b
"""

'''
Implemente o diagrama de Classes representado na imagem em anexo. Siga as seguintes regras:

Regra 1: Os atributos devem estar privados, logo devem ser definidos com duplo underline __ como mostrado na documentação. Exemplo: _nome ou _codigo.
Regra 2: Acessar os atributos/propriedades privados através dos métodos/funções públicos GET e SET.
Regra 3: O método gettotalrecebido() da classe Funcionário é abstrato e deve ser de declarado e reescrito em suas respectivas heranças.
Dado um número N de funcionários a serem cadastrados, crie uma lista com estes funcionários que podem ser (1) CLT ou (2) Comissionado. Mostre em tela a lista de funcionários ordenada pelo atributo codigo.
'''

################################################################
######################PARTE POO ################################
###############################################################
from abc import ABC, abstractmethod
class Pessoa(ABC):
  total = 0  # apartir desse valor atualizamos quanto a pessoa ganha  # tem que ficar aqui para reseter quando criar outra pessoa
  @abstractmethod
  def __init__(self,codigo,nome,endereco):
    self.__codigo = codigo # o diagrama indicam que sao rpviados
    self.__nome = nome 
    self.__endereco = endereco
  def setcodigo(self,codigo): # no diagrama fala que é publico
    self.__codigo = codigo
  def setnome(self,nome):
    self.__nome = nome
  def setendereco(self,endereco):
    self.__endereco = endereco
  def getcodigo(self):
    return self.__codigo
  def getnome(self):
    return self.__nome
  def getendereco(self):
    return self.__endereco
  def get_total_recebido(self): # metodo abstrato
    pass

class Funcionario(Pessoa):
  def __init__(self,salariobase):
    self.__salariobase = salariobase
  def setsalariobase(self,salariobase):
    self.__salariobase = salariobase
  def getsalariobase(self):
    return self.__salariobase
  def get_total_recebido(self):
    Pessoa.total += float(self.getsalariobase())
    return Pessoa.total


class Clt(Funcionario):
  def __init__(self,vale_transporte,vale_alimentacao):
    self.__vale_transporte = float(vale_transporte)
    self.__vale_alimentacao = float(vale_alimentacao)
  def setalimentacao(self,vale_alimentacao):
    self.__vale_alimentacao = float(vale_alimentacao)
  def settransporte(self,vale_transporte):
    self.__vale_transporte = float(vale_transporte)
  def getalimentacao(self):
    return self.__vale_alimentacao
  def gettrasnporte(self):
    return self.__vale_transporte    
  def get_total_recebido(self):
    return float(self.getsalariobase()) + float(self.getalimentacao()) + float(self.gettrasnporte())
  def __str__(self): # não achei modo mais inteligente de fazer isso , talvez seria melhor ter o metodo __str__ nas outras classes e usar aqui , por meio da herança , mas o diagrama não indica isso então foi manualmente mesmo
    string = 'Tipo: Clt' + '\n'
    string += f'Nome: {self.getnome()}' +'\n'
    string += f'Endereco: {self.getendereco()}' + '\n'
    string += f'Salario Base: {self.getsalariobase()}' + '\n'
    string += f'Transporte: {self.gettrasnporte()}' + '\n'
    string += f'Alimentacao: {self.getalimentacao()}' + '\n'
    string += f'Total Recebido: {self.get_total_recebido()}' + '\n'
    return string

class Comissionado(Funcionario):
  def __init__(self,vendas,comisao):
    self.__vendas = int(vendas)
    self.__comisao = float(comisao)
  def setvendas(self,vendas):
    self.__vendas = int(vendas)
  def setcomisao(self,comisao):
    self.__comisao = float(comisao)
  def getvendas(self):
    return self.__vendas 
  def getcomisao(self):
    return self.__comisao
  def get_total_recebido(self):
    return float(self.getsalariobase()) + float(self.getcomisao())*float(self.getvendas())
  def __str__(self): # não achei modo mais inteligente de fazer isso , talvez seria melhor ter o metodo __str__ nas outras classes e usar aqui , por meio da herança , mas o diagrama não indica isso então foi manualmente mesmo
    string = 'Tipo: Comissionado' + '\n'
    string += f'Nome: {self.getnome()}' +'\n'
    string += f'Endereco: {self.getendereco()}' + '\n'
    string += f'Salario Base: {self.getsalariobase()}' + '\n'
    string += f'Vendas: {self.getvendas()}' + '\n'
    string += f'Comissao: {self.getcomisao()}' + '\n'
    string += f'Total Recebido: {self.get_total_recebido()}' + '\n'
    return string
#################################################################################################
######################## Parte tratamento dos dados #############################################
#################################################################################################
n = int(input())
lista = []
dicionario = dict()
for i in range(n):
  tipo = int(input().rstrip())
  codigo = int(input().rstrip())
  nome = input().rstrip()
  endereco = input().rstrip()
  salario = float(input().rstrip())
  entrada_1 = input().rstrip()
  entrada_2 = input().rstrip()
  if tipo == 1:
    objeto = Clt(float(entrada_1),float(entrada_2))
    objeto.setcodigo(codigo)
    objeto.setnome(nome)
    objeto.setendereco(endereco)
    objeto.setsalariobase(salario)
    lista.append(objeto)   
  if tipo == 2:
    objeto = Comissionado(int(entrada_1),float(entrada_2))
    objeto.setcodigo(codigo)
    objeto.setnome(nome)
    objeto.setendereco(endereco)
    objeto.setsalariobase(salario)
    lista.append(objeto)



lista.sort(key = lambda x : x.getcodigo())
for r in lista:
  print(r)